# # """
# # Detección de formas geométricas en tiempo real (webcam)
# # Teclas:
# #   T  -> alterna pipeline (CANNY <-> ADAPTATIVO)
# #   I  -> mostrar/ocultar info
# #   S  -> guardar captura anotada (carpeta ./capturas)
# #   R  -> reset de controles a valores por defecto
# #   ESC-> salir
# # """

# import cv2
# import numpy as np
# import os
# import time
# from math import pi
# from datetime import datetime

# # ======= Valores por defecto =======
# DESIRED_WIDTH, DESIRED_HEIGHT, DESIRED_FPS = 1280, 720, 30
# DEF_MIN_AREA       = 600
# DEF_CANNY_T1       = 100
# DEF_CANNY_T2       = 220
# DEF_CIRC_THR_x1000 = 800  # circularidad*1000 (0.80 -> 800)
# DEF_ADAPT_BLOCK    = 15   # impar >=3
# DEF_ADAPT_C        = 2

# # ======= Utils =======
# def ensure_dir(p): 
#     if not os.path.exists(p): os.makedirs(p)

# def make_odd(x: int) -> int:
#     return x if x % 2 == 1 else x + 1

# def try_open_camera():
#     backends = [cv2.CAP_DSHOW, cv2.CAP_MSMF, 0]  # 0 => default
#     for idx in range(3):          # prueba índices 0..2
#         for be in backends:
#             cap = cv2.VideoCapture(idx, be) if be != 0 else cv2.VideoCapture(idx)
#             if cap.isOpened():
#                 return cap, idx, be
#             cap.release()
#     raise RuntimeError("No encontré cámaras (cierra Meet/Zoom/OBS y revisa permisos).")

# def set_cam_props(cap):
#     cap.set(cv2.CAP_PROP_FRAME_WIDTH,  DESIRED_WIDTH)
#     cap.set(cv2.CAP_PROP_FRAME_HEIGHT, DESIRED_HEIGHT)
#     cap.set(cv2.CAP_PROP_FPS,          DESIRED_FPS)

# # ======= Trackbars =======
# WIN_CTRL = "Controles"

# def nothing(_): pass

# def create_control_window():
#     cv2.namedWindow(WIN_CTRL, cv2.WINDOW_NORMAL)
#     cv2.resizeWindow(WIN_CTRL, 420, 320)
#     cv2.createTrackbar("MIN_AREA",     WIN_CTRL, DEF_MIN_AREA, 10000, nothing)
#     cv2.createTrackbar("CANNY_T1",     WIN_CTRL, DEF_CANNY_T1, 1000,  nothing)
#     cv2.createTrackbar("CANNY_T2",     WIN_CTRL, DEF_CANNY_T2, 1000,  nothing)
#     cv2.createTrackbar("CIRC_x1000",   WIN_CTRL, DEF_CIRC_THR_x1000, 1000, nothing)
#     cv2.createTrackbar("ADAPT_BLOCK",  WIN_CTRL, DEF_ADAPT_BLOCK, 99,  nothing)
#     cv2.createTrackbar("ADAPT_C",      WIN_CTRL, DEF_ADAPT_C, 10,      nothing)

# def read_controls():
#     min_area   = max(0, cv2.getTrackbarPos("MIN_AREA",   WIN_CTRL))
#     t1         = cv2.getTrackbarPos("CANNY_T1",          WIN_CTRL)
#     t2         = cv2.getTrackbarPos("CANNY_T2",          WIN_CTRL)
#     circ_x1000 = cv2.getTrackbarPos("CIRC_x1000",        WIN_CTRL)
#     blk        = cv2.getTrackbarPos("ADAPT_BLOCK",       WIN_CTRL)
#     cval       = cv2.getTrackbarPos("ADAPT_C",           WIN_CTRL)
#     # Normalizaciones/garantías
#     blk = max(3, make_odd(blk))
#     if t2 < t1: t2 = t1 + 1
#     return min_area, t1, t2, circ_x1000/1000.0, blk, cval

# def reset_controls():
#     cv2.setTrackbarPos("MIN_AREA",   WIN_CTRL, DEF_MIN_AREA)
#     cv2.setTrackbarPos("CANNY_T1",   WIN_CTRL, DEF_CANNY_T1)
#     cv2.setTrackbarPos("CANNY_T2",   WIN_CTRL, DEF_CANNY_T2)
#     cv2.setTrackbarPos("CIRC_x1000", WIN_CTRL, DEF_CIRC_THR_x1000)
#     cv2.setTrackbarPos("ADAPT_BLOCK",WIN_CTRL, DEF_ADAPT_BLOCK)
#     cv2.setTrackbarPos("ADAPT_C",    WIN_CTRL, DEF_ADAPT_C)

# # ======= Núcleo =======
# def classify_shape(contour, min_area, circ_thr):
#     area = cv2.contourArea(contour)
#     if area < min_area:
#         return None, {}

#     peri   = cv2.arcLength(contour, True)
#     approx = cv2.approxPolyDP(contour, 0.02 * peri, True)
#     vertices = len(approx)

#     rect = cv2.minAreaRect(contour)  # ((cx,cy),(w,h),angle)
#     (cx, cy), (w, h), angle = rect
#     box = cv2.boxPoints(rect)
#     box = np.intp(box)

#     circularity = (4 * pi * area) / (peri * peri + 1e-9)

#     if vertices == 3:
#         shape = "Triangulo"
#     elif vertices == 4:
#         x, y, w_b, h_b = cv2.boundingRect(approx)
#         ar = w_b / float(h_b) if h_b > 0 else 0
#         shape = "Cuadrado" if 0.95 <= ar <= 1.05 else "Rectangulo"
#     elif vertices == 5:
#         shape = "Pentagono"
#     else:
#         shape = "Circulo" if circularity >= circ_thr else f"Poligono({vertices})"

#     return shape, {
#         "area": int(area),
#         "peri": int(peri),
#         "vertices": vertices,
#         "circularidad": round(float(circularity), 3),
#         "angulo": round(float(angle), 1),
#         "cx": int(cx), "cy": int(cy),
#         "box": box
#     }

# def process_frame(frame, use_adaptive, params):
#     min_area, t1, t2, circ_thr, blk, cval = params
#     gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
#     gray = cv2.GaussianBlur(gray, (5,5), 0)

#     if use_adaptive:
#         work = cv2.adaptiveThreshold(
#             gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY,
#             blk, cval
#         )
#     else:
#         edges = cv2.Canny(gray, t1, t2)
#         edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, np.ones((3,3),np.uint8), 1)
#         work = edges

#     contours, _ = cv2.findContours(work, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

#     out = frame.copy()
#     for c in contours:
#         shape, info = classify_shape(c, min_area, circ_thr)
#         if not shape: 
#             continue
#         cv2.drawContours(out, [info["box"]], 0, (0,255,0), 2)
#         label = f'{shape} A:{info["area"]} V:{info["vertices"]} C:{info["circularidad"]}'
#         cv2.putText(out, label, (info["cx"]-70, info["cy"]-10),
#                     cv2.FONT_HERSHEY_SIMPLEX, 0.55, (20,20,20), 2, cv2.LINE_AA)
#         cv2.circle(out, (info["cx"], info["cy"]), 3, (255,0,0), -1)

#     debug = cv2.cvtColor(work, cv2.COLOR_GRAY2BGR)
#     return out, debug

# def draw_overlay(img, show_info, mode_adapt, fps, cap):
#     if not show_info: 
#         return
#     rw = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
#     rh = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
#     rf = int(cap.get(cv2.CAP_PROP_FPS))
#     lines = [
#         f"Deteccion de formas | Modo: {'Adaptativo' if mode_adapt else 'Canny'} (T)",
#         f"Resolucion real reportada: {rw}x{rh} @ {rf}fps | FPS medidos: {fps:.1f}",
#         "Teclas: [T] modo  [I] info  [S] guardar  [R] reset  [ESC] salir",
#     ]
#     y0 = 22
#     for i, txt in enumerate(lines):
#         y = y0 + i*22
#         cv2.putText(img, txt, (10, y), cv2.FONT_HERSHEY_SIMPLEX, 0.55, (0,0,0), 3, cv2.LINE_AA)
#         cv2.putText(img, txt, (10, y), cv2.FONT_HERSHEY_SIMPLEX, 0.55, (255,255,255), 1, cv2.LINE_AA)

# def main():
#     ensure_dir("capturas")
#     create_control_window()
#     reset_controls()

#     cap, idx, backend = try_open_camera()
#     set_cam_props(cap)
#     print(f"[OK] Cámara abierta en índice {idx} | backend={backend}")

#     use_adaptive = False
#     show_info    = True

#     last = time.perf_counter()
#     fps  = 0.0

#     while True:
#         ok, frame = cap.read()
#         if not ok:
#             print("[WARN] No pude leer frame.")
#             break

#         now = time.perf_counter()
#         dt  = now - last
#         last = now
#         if dt > 0:
#             fps = 0.9*fps + 0.1*(1.0/dt) if fps > 0 else 1.0/dt

#         params = read_controls()
#         out, dbg = process_frame(frame, use_adaptive, params)

#         view = np.hstack([out, dbg])
#         draw_overlay(view, show_info, use_adaptive, fps, cap)
#         cv2.imshow("Deteccion de formas (Resultado | Binaria)", view)

#         key = cv2.waitKey(1) & 0xFF
#         if key == 27:  # ESC
#             break
#         elif key in (ord('t'), ord('T')):
#             use_adaptive = not use_adaptive
#         elif key in (ord('i'), ord('I')):
#             show_info = not show_info
#         elif key in (ord('s'), ord('S')):
#             ts = datetime.now().strftime("%Y%m%d_%H%M%S")
#             path = os.path.join("capturas", f"shapes_{ts}.png")
#             cv2.imwrite(path, out)
#             print(f"[OK] Captura guardada: {path}")
#         elif key in (ord('r'), ord('R')):
#             reset_controls()

#     cap.release()
#     cv2.destroyAllWindows()

# if __name__ == "__main__":
#     main()

# """
# Detección de formas geométricas en tiempo real (webcam) con panel lado a lado redimensionado.

# Teclas:
#   T  -> alterna pipeline (CANNY <-> ADAPTATIVO)
#   I  -> mostrar/ocultar overlay de info
#   S  -> guardar captura anotada (carpeta ./capturas)
#   R  -> reset de controles a valores por defecto
#   ESC-> salir
# """

import cv2
import numpy as np
import os
import time
from math import pi
from datetime import datetime

# ======= Resolución deseada de la cámara =======
DESIRED_WIDTH, DESIRED_HEIGHT, DESIRED_FPS = 1280, 720, 30

# ======= Redimensión del panel combinado (lado a lado) =======
# Modo 1: fijar ancho objetivo y mantener proporción
PANEL_TARGET_WIDTH  = 960
# Modo 2: (opcional) fijar alto objetivo en lugar de ancho
USE_TARGET_HEIGHT   = False
PANEL_TARGET_HEIGHT = 540

# ======= Valores por defecto de controles =======
DEF_MIN_AREA       = 600
DEF_CANNY_T1       = 100
DEF_CANNY_T2       = 220
DEF_CIRC_THR_x1000 = 800  # circularidad*1000 (0.80 -> 800)
DEF_ADAPT_BLOCK    = 15   # impar >=3
DEF_ADAPT_C        = 2

# ======= Utils =======
def ensure_dir(p): 
    if not os.path.exists(p): os.makedirs(p)

def make_odd(x: int) -> int:
    return x if x % 2 == 1 else x + 1

def try_open_camera():
    """Intenta abrir la webcam probando backends e índices."""
    backends = [cv2.CAP_DSHOW, cv2.CAP_MSMF, 0]  # 0 => default
    for idx in range(3):          # prueba índices 0..2
        for be in backends:
            cap = cv2.VideoCapture(idx, be) if be != 0 else cv2.VideoCapture(idx)
            if cap.isOpened():
                return cap, idx, be
            cap.release()
    raise RuntimeError("No encontré cámaras (cierra Meet/Zoom/OBS y revisa permisos).")

def set_cam_props(cap):
    cap.set(cv2.CAP_PROP_FRAME_WIDTH,  DESIRED_WIDTH)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, DESIRED_HEIGHT)
    cap.set(cv2.CAP_PROP_FPS,          DESIRED_FPS)

# ======= Trackbars =======
WIN_CTRL = "Controles"

def nothing(_): pass

def create_control_window():
    cv2.namedWindow(WIN_CTRL, cv2.WINDOW_NORMAL)
    cv2.resizeWindow(WIN_CTRL, 420, 320)
    cv2.createTrackbar("MIN_AREA",     WIN_CTRL, DEF_MIN_AREA, 10000, nothing)
    cv2.createTrackbar("CANNY_T1",     WIN_CTRL, DEF_CANNY_T1, 1000,  nothing)
    cv2.createTrackbar("CANNY_T2",     WIN_CTRL, DEF_CANNY_T2, 1000,  nothing)
    cv2.createTrackbar("CIRC_x1000",   WIN_CTRL, DEF_CIRC_THR_x1000, 1000, nothing)
    cv2.createTrackbar("ADAPT_BLOCK",  WIN_CTRL, DEF_ADAPT_BLOCK, 99,  nothing)
    cv2.createTrackbar("ADAPT_C",      WIN_CTRL, DEF_ADAPT_C, 10,      nothing)

def read_controls():
    min_area   = max(0, cv2.getTrackbarPos("MIN_AREA",   WIN_CTRL))
    t1         = cv2.getTrackbarPos("CANNY_T1",          WIN_CTRL)
    t2         = cv2.getTrackbarPos("CANNY_T2",          WIN_CTRL)
    circ_x1000 = cv2.getTrackbarPos("CIRC_x1000",        WIN_CTRL)
    blk        = cv2.getTrackbarPos("ADAPT_BLOCK",       WIN_CTRL)
    cval       = cv2.getTrackbarPos("ADAPT_C",           WIN_CTRL)
    blk = max(3, make_odd(blk))
    if t2 < t1: t2 = t1 + 1
    return min_area, t1, t2, circ_x1000/1000.0, blk, cval

def reset_controls():
    cv2.setTrackbarPos("MIN_AREA",   WIN_CTRL, DEF_MIN_AREA)
    cv2.setTrackbarPos("CANNY_T1",   WIN_CTRL, DEF_CANNY_T1)
    cv2.setTrackbarPos("CANNY_T2",   WIN_CTRL, DEF_CANNY_T2)
    cv2.setTrackbarPos("CIRC_x1000", WIN_CTRL, DEF_CIRC_THR_x1000)
    cv2.setTrackbarPos("ADAPT_BLOCK",WIN_CTRL, DEF_ADAPT_BLOCK)
    cv2.setTrackbarPos("ADAPT_C",    WIN_CTRL, DEF_ADAPT_C)

# ======= Núcleo =======
def classify_shape(contour, min_area, circ_thr):
    area = cv2.contourArea(contour)
    if area < min_area:
        return None, {}

    peri   = cv2.arcLength(contour, True)
    approx = cv2.approxPolyDP(contour, 0.02 * peri, True)
    vertices = len(approx)

    rect = cv2.minAreaRect(contour)  # ((cx,cy),(w,h),angle)
    (cx, cy), (w, h), angle = rect
    box = cv2.boxPoints(rect)
    box = np.intp(box)

    circularity = (4 * pi * area) / (peri * peri + 1e-9)

    if vertices == 3:
        shape = "Triangulo"
    elif vertices == 4:
        x, y, w_b, h_b = cv2.boundingRect(approx)
        ar = w_b / float(h_b) if h_b > 0 else 0
        shape = "Cuadrado" if 0.95 <= ar <= 1.05 else "Rectangulo"
    elif vertices == 5:
        shape = "Pentagono"
    else:
        shape = "Circulo" if circularity >= circ_thr else f"Poligono({vertices})"

    return shape, {
        "area": int(area),
        "peri": int(peri),
        "vertices": vertices,
        "circularidad": round(float(circularity), 3),
        "angulo": round(float(angle), 1),
        "cx": int(cx), "cy": int(cy),
        "box": box
    }

def process_frame(frame, use_adaptive, params):
    min_area, t1, t2, circ_thr, blk, cval = params
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (5,5), 0)

    if use_adaptive:
        work = cv2.adaptiveThreshold(
            gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY,
            blk, cval
        )
    else:
        edges = cv2.Canny(gray, t1, t2)
        edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, np.ones((3,3),np.uint8), 1)
        work = edges

    contours, _ = cv2.findContours(work, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    out = frame.copy()
    for c in contours:
        shape, info = classify_shape(c, min_area, circ_thr)
        if not shape: 
            continue
        cv2.drawContours(out, [info["box"]], 0, (0,255,0), 2)
        label = f'{shape} A:{info["area"]} V:{info["vertices"]} C:{info["circularidad"]}'
        cv2.putText(out, label, (info["cx"]-70, info["cy"]-10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.55, (20,20,20), 2, cv2.LINE_AA)
        cv2.circle(out, (info["cx"], info["cy"]), 3, (255,0,0), -1)

    debug = cv2.cvtColor(work, cv2.COLOR_GRAY2BGR)
    return out, debug

def draw_overlay(img, show_info, mode_adapt, fps, cap):
    if not show_info: 
        return
    rw = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    rh = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    rf = int(cap.get(cv2.CAP_PROP_FPS))
    lines = [
        f"Deteccion de formas | Modo: {'Adaptativo' if mode_adapt else 'Canny'} (T)",
        f"Resolucion real: {rw}x{rh} @ {rf}fps | FPS medidos: {fps:.1f}",
        "Teclas: [T] modo  [I] info  [S] guardar  [R] reset  [ESC] salir",
    ]
    y0 = 22
    for i, txt in enumerate(lines):
        y = y0 + i*22
        cv2.putText(img, txt, (10, y), cv2.FONT_HERSHEY_SIMPLEX, 0.55, (0,0,0), 3, cv2.LINE_AA)
        cv2.putText(img, txt, (10, y), cv2.FONT_HERSHEY_SIMPLEX, 0.55, (255,255,255), 1, cv2.LINE_AA)

# ======= Redimensionador de panel =======
def resize_panel(view):
    """
    Redimensiona el panel combinado (lado a lado) para que quepa en pantalla.
    Por defecto fija el ANCHO objetivo (PANEL_TARGET_WIDTH).
    Si USE_TARGET_HEIGHT=True, fija el ALTO objetivo.
    """
    h, w = view.shape[:2]
    if USE_TARGET_HEIGHT:
        scale = PANEL_TARGET_HEIGHT / float(h)
        new_size = (int(w * scale), PANEL_TARGET_HEIGHT)
    else:
        scale = PANEL_TARGET_WIDTH / float(w)
        new_size = (PANEL_TARGET_WIDTH, int(h * scale))
    return cv2.resize(view, new_size, interpolation=cv2.INTER_AREA)

def main():
    ensure_dir("capturas")
    create_control_window()
    reset_controls()

    cap, idx, backend = try_open_camera()
    set_cam_props(cap)
    print(f"[OK] Cámara abierta en índice {idx} | backend={backend}")

    # Ventana principal redimensionable
    WIN_MAIN = "Deteccion de formas (Resultado | Binaria)"
    cv2.namedWindow(WIN_MAIN, cv2.WINDOW_NORMAL)

    use_adaptive = False
    show_info    = True

    last = time.perf_counter()
    fps  = 0.0

    while True:
        ok, frame = cap.read()
        if not ok:
            print("[WARN] No pude leer frame.")
            break

        # FPS medidos
        now = time.perf_counter()
        dt  = now - last
        last = now
        if dt > 0:
            fps = 0.9*fps + 0.1*(1.0/dt) if fps > 0 else 1.0/dt

        # Pipeline
        params = read_controls()
        out, dbg = process_frame(frame, use_adaptive, params)

        # Vista lado a lado y REDIMENSIÓN aplicada
        view = np.hstack([out, dbg])
        view = resize_panel(view)  # <<--- AQUÍ se ajusta el tamaño final

        # Overlay informativo
        draw_overlay(view, show_info, use_adaptive, fps, cap)

        # Mostrar
        cv2.imshow(WIN_MAIN, view)

        # Teclado
        key = cv2.waitKey(1) & 0xFF
        if key == 27:  # ESC
            break
        elif key in (ord('t'), ord('T')):
            use_adaptive = not use_adaptive
        elif key in (ord('i'), ord('I')):
            show_info = not show_info
        elif key in (ord('s'), ord('S')):
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            path = os.path.join("capturas", f"shapes_{ts}.png")
            cv2.imwrite(path, out)
            print(f"[OK] Captura guardada: {path}")
        elif key in (ord('r'), ord('R')):
            reset_controls()

    cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()

