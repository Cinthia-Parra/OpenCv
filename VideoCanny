import cv2 as cv
import numpy as np

cap = cv.VideoCapture(0)  # 0 = primera cámara (la integrada normalmente)  1, 2… = cámaras USB adicionales

cap.set(cv.CAP_PROP_FRAME_WIDTH, 1280) #Pides una resolución (ancho) 
cap.set(cv.CAP_PROP_FRAME_HEIGHT, 720) #(y alto).

use_adaptive = False  # False = usa Canny | True = usa Adaptativo

while True: #Inicia el bucle infinito para leer cuadros (frames) de la cámara en tiempo real.-la cámara me da imágenes sin parar hasta que yo decida salir
    success, frame = cap.read() 
    if not success:      #Si success=False, no hay imagen válida (cámara desconectada, error, etc.).
        break            #Sale del bucle si no se pudo leer. Evita crasheos.

#Escala de grises + Blur (preparación)
    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    gray = cv.GaussianBlur(gray, (5, 5), 0)
    
#Detector de bordes Canny
    edges = cv.Canny(gray, 100, 220)  # Detecta bordes:
                    # 100 = umbral bajo
                    # 220 = umbral alto
                    # Los pixeles con gradiente entre 100-220 se deciden como bordes
                    # Resultado: imagen binaria (blanco = borde, negro = fondo)

#Cerrar pequeños huecos en bordes
    kernel = cv.getStructuringElement(cv.MORPH_RECT, (3,3))
    edges = cv.morphologyEx(edges, cv.MORPH_CLOSE, kernel, iterations=1) # MORPH_CLOSE = dilatar y luego erosionar → cierra huecos pequeños en los bordes
                                                        # iterations=1 → lo aplica una sola vez y ya se hace por defecto pero es mejor dejarlo explicito
#Mostrar resultado (bordes en blanco sobre negro)
    cv.imshow("Paso 3 - Bordes con Canny (q para salir)", edges)
    
    key = cv.waitKey(1) & 0xFF
    if key == ord('q'):
        break

cap.release()
cv.destroyAllWindows()
